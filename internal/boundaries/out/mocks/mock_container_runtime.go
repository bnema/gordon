// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"io"

	"github.com/bnema/gordon/internal/boundaries/out"
	"github.com/bnema/gordon/internal/domain"
	mock "github.com/stretchr/testify/mock"
)

// NewMockContainerRuntime creates a new instance of MockContainerRuntime. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockContainerRuntime(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockContainerRuntime {
	mock := &MockContainerRuntime{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockContainerRuntime is an autogenerated mock type for the ContainerRuntime type
type MockContainerRuntime struct {
	mock.Mock
}

type MockContainerRuntime_Expecter struct {
	mock *mock.Mock
}

func (_m *MockContainerRuntime) EXPECT() *MockContainerRuntime_Expecter {
	return &MockContainerRuntime_Expecter{mock: &_m.Mock}
}

// ConnectContainerToNetwork provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) ConnectContainerToNetwork(ctx context.Context, containerName string, networkName string) error {
	ret := _mock.Called(ctx, containerName, networkName)

	if len(ret) == 0 {
		panic("no return value specified for ConnectContainerToNetwork")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, containerName, networkName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_ConnectContainerToNetwork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConnectContainerToNetwork'
type MockContainerRuntime_ConnectContainerToNetwork_Call struct {
	*mock.Call
}

// ConnectContainerToNetwork is a helper method to define mock.On call
//   - ctx context.Context
//   - containerName string
//   - networkName string
func (_e *MockContainerRuntime_Expecter) ConnectContainerToNetwork(ctx interface{}, containerName interface{}, networkName interface{}) *MockContainerRuntime_ConnectContainerToNetwork_Call {
	return &MockContainerRuntime_ConnectContainerToNetwork_Call{Call: _e.mock.On("ConnectContainerToNetwork", ctx, containerName, networkName)}
}

func (_c *MockContainerRuntime_ConnectContainerToNetwork_Call) Run(run func(ctx context.Context, containerName string, networkName string)) *MockContainerRuntime_ConnectContainerToNetwork_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_ConnectContainerToNetwork_Call) Return(err error) *MockContainerRuntime_ConnectContainerToNetwork_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_ConnectContainerToNetwork_Call) RunAndReturn(run func(ctx context.Context, containerName string, networkName string) error) *MockContainerRuntime_ConnectContainerToNetwork_Call {
	_c.Call.Return(run)
	return _c
}

// CopyFromContainer provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) CopyFromContainer(ctx context.Context, containerID string, srcPath string) ([]byte, error) {
	ret := _mock.Called(ctx, containerID, srcPath)

	if len(ret) == 0 {
		panic("no return value specified for CopyFromContainer")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) ([]byte, error)); ok {
		return returnFunc(ctx, containerID, srcPath)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) []byte); ok {
		r0 = returnFunc(ctx, containerID, srcPath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, containerID, srcPath)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_CopyFromContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyFromContainer'
type MockContainerRuntime_CopyFromContainer_Call struct {
	*mock.Call
}

// CopyFromContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
//   - srcPath string
func (_e *MockContainerRuntime_Expecter) CopyFromContainer(ctx interface{}, containerID interface{}, srcPath interface{}) *MockContainerRuntime_CopyFromContainer_Call {
	return &MockContainerRuntime_CopyFromContainer_Call{Call: _e.mock.On("CopyFromContainer", ctx, containerID, srcPath)}
}

func (_c *MockContainerRuntime_CopyFromContainer_Call) Run(run func(ctx context.Context, containerID string, srcPath string)) *MockContainerRuntime_CopyFromContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_CopyFromContainer_Call) Return(bytes []byte, err error) *MockContainerRuntime_CopyFromContainer_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *MockContainerRuntime_CopyFromContainer_Call) RunAndReturn(run func(ctx context.Context, containerID string, srcPath string) ([]byte, error)) *MockContainerRuntime_CopyFromContainer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateContainer provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) CreateContainer(ctx context.Context, config *domain.ContainerConfig) (*domain.Container, error) {
	ret := _mock.Called(ctx, config)

	if len(ret) == 0 {
		panic("no return value specified for CreateContainer")
	}

	var r0 *domain.Container
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.ContainerConfig) (*domain.Container, error)); ok {
		return returnFunc(ctx, config)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.ContainerConfig) *domain.Container); ok {
		r0 = returnFunc(ctx, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Container)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *domain.ContainerConfig) error); ok {
		r1 = returnFunc(ctx, config)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_CreateContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateContainer'
type MockContainerRuntime_CreateContainer_Call struct {
	*mock.Call
}

// CreateContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - config *domain.ContainerConfig
func (_e *MockContainerRuntime_Expecter) CreateContainer(ctx interface{}, config interface{}) *MockContainerRuntime_CreateContainer_Call {
	return &MockContainerRuntime_CreateContainer_Call{Call: _e.mock.On("CreateContainer", ctx, config)}
}

func (_c *MockContainerRuntime_CreateContainer_Call) Run(run func(ctx context.Context, config *domain.ContainerConfig)) *MockContainerRuntime_CreateContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *domain.ContainerConfig
		if args[1] != nil {
			arg1 = args[1].(*domain.ContainerConfig)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_CreateContainer_Call) Return(container *domain.Container, err error) *MockContainerRuntime_CreateContainer_Call {
	_c.Call.Return(container, err)
	return _c
}

func (_c *MockContainerRuntime_CreateContainer_Call) RunAndReturn(run func(ctx context.Context, config *domain.ContainerConfig) (*domain.Container, error)) *MockContainerRuntime_CreateContainer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNetwork provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) CreateNetwork(ctx context.Context, name string, options map[string]string) error {
	ret := _mock.Called(ctx, name, options)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetwork")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, map[string]string) error); ok {
		r0 = returnFunc(ctx, name, options)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_CreateNetwork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNetwork'
type MockContainerRuntime_CreateNetwork_Call struct {
	*mock.Call
}

// CreateNetwork is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - options map[string]string
func (_e *MockContainerRuntime_Expecter) CreateNetwork(ctx interface{}, name interface{}, options interface{}) *MockContainerRuntime_CreateNetwork_Call {
	return &MockContainerRuntime_CreateNetwork_Call{Call: _e.mock.On("CreateNetwork", ctx, name, options)}
}

func (_c *MockContainerRuntime_CreateNetwork_Call) Run(run func(ctx context.Context, name string, options map[string]string)) *MockContainerRuntime_CreateNetwork_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 map[string]string
		if args[2] != nil {
			arg2 = args[2].(map[string]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_CreateNetwork_Call) Return(err error) *MockContainerRuntime_CreateNetwork_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_CreateNetwork_Call) RunAndReturn(run func(ctx context.Context, name string, options map[string]string) error) *MockContainerRuntime_CreateNetwork_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVolume provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) CreateVolume(ctx context.Context, volumeName string) error {
	ret := _mock.Called(ctx, volumeName)

	if len(ret) == 0 {
		panic("no return value specified for CreateVolume")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, volumeName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_CreateVolume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVolume'
type MockContainerRuntime_CreateVolume_Call struct {
	*mock.Call
}

// CreateVolume is a helper method to define mock.On call
//   - ctx context.Context
//   - volumeName string
func (_e *MockContainerRuntime_Expecter) CreateVolume(ctx interface{}, volumeName interface{}) *MockContainerRuntime_CreateVolume_Call {
	return &MockContainerRuntime_CreateVolume_Call{Call: _e.mock.On("CreateVolume", ctx, volumeName)}
}

func (_c *MockContainerRuntime_CreateVolume_Call) Run(run func(ctx context.Context, volumeName string)) *MockContainerRuntime_CreateVolume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_CreateVolume_Call) Return(err error) *MockContainerRuntime_CreateVolume_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_CreateVolume_Call) RunAndReturn(run func(ctx context.Context, volumeName string) error) *MockContainerRuntime_CreateVolume_Call {
	_c.Call.Return(run)
	return _c
}

// DisconnectContainerFromNetwork provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) DisconnectContainerFromNetwork(ctx context.Context, containerName string, networkName string) error {
	ret := _mock.Called(ctx, containerName, networkName)

	if len(ret) == 0 {
		panic("no return value specified for DisconnectContainerFromNetwork")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, containerName, networkName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_DisconnectContainerFromNetwork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisconnectContainerFromNetwork'
type MockContainerRuntime_DisconnectContainerFromNetwork_Call struct {
	*mock.Call
}

// DisconnectContainerFromNetwork is a helper method to define mock.On call
//   - ctx context.Context
//   - containerName string
//   - networkName string
func (_e *MockContainerRuntime_Expecter) DisconnectContainerFromNetwork(ctx interface{}, containerName interface{}, networkName interface{}) *MockContainerRuntime_DisconnectContainerFromNetwork_Call {
	return &MockContainerRuntime_DisconnectContainerFromNetwork_Call{Call: _e.mock.On("DisconnectContainerFromNetwork", ctx, containerName, networkName)}
}

func (_c *MockContainerRuntime_DisconnectContainerFromNetwork_Call) Run(run func(ctx context.Context, containerName string, networkName string)) *MockContainerRuntime_DisconnectContainerFromNetwork_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_DisconnectContainerFromNetwork_Call) Return(err error) *MockContainerRuntime_DisconnectContainerFromNetwork_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_DisconnectContainerFromNetwork_Call) RunAndReturn(run func(ctx context.Context, containerName string, networkName string) error) *MockContainerRuntime_DisconnectContainerFromNetwork_Call {
	_c.Call.Return(run)
	return _c
}

// ExecInContainer provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) ExecInContainer(ctx context.Context, containerID string, cmd []string) (*out.ExecResult, error) {
	ret := _mock.Called(ctx, containerID, cmd)

	if len(ret) == 0 {
		panic("no return value specified for ExecInContainer")
	}

	var r0 *out.ExecResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string) (*out.ExecResult, error)); ok {
		return returnFunc(ctx, containerID, cmd)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, []string) *out.ExecResult); ok {
		r0 = returnFunc(ctx, containerID, cmd)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*out.ExecResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = returnFunc(ctx, containerID, cmd)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_ExecInContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecInContainer'
type MockContainerRuntime_ExecInContainer_Call struct {
	*mock.Call
}

// ExecInContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
//   - cmd []string
func (_e *MockContainerRuntime_Expecter) ExecInContainer(ctx interface{}, containerID interface{}, cmd interface{}) *MockContainerRuntime_ExecInContainer_Call {
	return &MockContainerRuntime_ExecInContainer_Call{Call: _e.mock.On("ExecInContainer", ctx, containerID, cmd)}
}

func (_c *MockContainerRuntime_ExecInContainer_Call) Run(run func(ctx context.Context, containerID string, cmd []string)) *MockContainerRuntime_ExecInContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_ExecInContainer_Call) Return(execResult *out.ExecResult, err error) *MockContainerRuntime_ExecInContainer_Call {
	_c.Call.Return(execResult, err)
	return _c
}

func (_c *MockContainerRuntime_ExecInContainer_Call) RunAndReturn(run func(ctx context.Context, containerID string, cmd []string) (*out.ExecResult, error)) *MockContainerRuntime_ExecInContainer_Call {
	_c.Call.Return(run)
	return _c
}

// GetContainerExposedPorts provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) GetContainerExposedPorts(ctx context.Context, containerID string) ([]int, error) {
	ret := _mock.Called(ctx, containerID)

	if len(ret) == 0 {
		panic("no return value specified for GetContainerExposedPorts")
	}

	var r0 []int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]int, error)); ok {
		return returnFunc(ctx, containerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []int); ok {
		r0 = returnFunc(ctx, containerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, containerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_GetContainerExposedPorts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContainerExposedPorts'
type MockContainerRuntime_GetContainerExposedPorts_Call struct {
	*mock.Call
}

// GetContainerExposedPorts is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
func (_e *MockContainerRuntime_Expecter) GetContainerExposedPorts(ctx interface{}, containerID interface{}) *MockContainerRuntime_GetContainerExposedPorts_Call {
	return &MockContainerRuntime_GetContainerExposedPorts_Call{Call: _e.mock.On("GetContainerExposedPorts", ctx, containerID)}
}

func (_c *MockContainerRuntime_GetContainerExposedPorts_Call) Run(run func(ctx context.Context, containerID string)) *MockContainerRuntime_GetContainerExposedPorts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_GetContainerExposedPorts_Call) Return(ints []int, err error) *MockContainerRuntime_GetContainerExposedPorts_Call {
	_c.Call.Return(ints, err)
	return _c
}

func (_c *MockContainerRuntime_GetContainerExposedPorts_Call) RunAndReturn(run func(ctx context.Context, containerID string) ([]int, error)) *MockContainerRuntime_GetContainerExposedPorts_Call {
	_c.Call.Return(run)
	return _c
}

// GetContainerLogs provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) GetContainerLogs(ctx context.Context, containerID string, follow bool) (io.ReadCloser, error) {
	ret := _mock.Called(ctx, containerID, follow)

	if len(ret) == 0 {
		panic("no return value specified for GetContainerLogs")
	}

	var r0 io.ReadCloser
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) (io.ReadCloser, error)); ok {
		return returnFunc(ctx, containerID, follow)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) io.ReadCloser); ok {
		r0 = returnFunc(ctx, containerID, follow)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = returnFunc(ctx, containerID, follow)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_GetContainerLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContainerLogs'
type MockContainerRuntime_GetContainerLogs_Call struct {
	*mock.Call
}

// GetContainerLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
//   - follow bool
func (_e *MockContainerRuntime_Expecter) GetContainerLogs(ctx interface{}, containerID interface{}, follow interface{}) *MockContainerRuntime_GetContainerLogs_Call {
	return &MockContainerRuntime_GetContainerLogs_Call{Call: _e.mock.On("GetContainerLogs", ctx, containerID, follow)}
}

func (_c *MockContainerRuntime_GetContainerLogs_Call) Run(run func(ctx context.Context, containerID string, follow bool)) *MockContainerRuntime_GetContainerLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_GetContainerLogs_Call) Return(readCloser io.ReadCloser, err error) *MockContainerRuntime_GetContainerLogs_Call {
	_c.Call.Return(readCloser, err)
	return _c
}

func (_c *MockContainerRuntime_GetContainerLogs_Call) RunAndReturn(run func(ctx context.Context, containerID string, follow bool) (io.ReadCloser, error)) *MockContainerRuntime_GetContainerLogs_Call {
	_c.Call.Return(run)
	return _c
}

// GetContainerNetwork provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) GetContainerNetwork(ctx context.Context, containerID string) (string, error) {
	ret := _mock.Called(ctx, containerID)

	if len(ret) == 0 {
		panic("no return value specified for GetContainerNetwork")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return returnFunc(ctx, containerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, containerID)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, containerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_GetContainerNetwork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContainerNetwork'
type MockContainerRuntime_GetContainerNetwork_Call struct {
	*mock.Call
}

// GetContainerNetwork is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
func (_e *MockContainerRuntime_Expecter) GetContainerNetwork(ctx interface{}, containerID interface{}) *MockContainerRuntime_GetContainerNetwork_Call {
	return &MockContainerRuntime_GetContainerNetwork_Call{Call: _e.mock.On("GetContainerNetwork", ctx, containerID)}
}

func (_c *MockContainerRuntime_GetContainerNetwork_Call) Run(run func(ctx context.Context, containerID string)) *MockContainerRuntime_GetContainerNetwork_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_GetContainerNetwork_Call) Return(s string, err error) *MockContainerRuntime_GetContainerNetwork_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockContainerRuntime_GetContainerNetwork_Call) RunAndReturn(run func(ctx context.Context, containerID string) (string, error)) *MockContainerRuntime_GetContainerNetwork_Call {
	_c.Call.Return(run)
	return _c
}

// GetContainerNetworkInfo provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) GetContainerNetworkInfo(ctx context.Context, containerID string) (string, int, error) {
	ret := _mock.Called(ctx, containerID)

	if len(ret) == 0 {
		panic("no return value specified for GetContainerNetworkInfo")
	}

	var r0 string
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, int, error)); ok {
		return returnFunc(ctx, containerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, containerID)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) int); ok {
		r1 = returnFunc(ctx, containerID)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = returnFunc(ctx, containerID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockContainerRuntime_GetContainerNetworkInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContainerNetworkInfo'
type MockContainerRuntime_GetContainerNetworkInfo_Call struct {
	*mock.Call
}

// GetContainerNetworkInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
func (_e *MockContainerRuntime_Expecter) GetContainerNetworkInfo(ctx interface{}, containerID interface{}) *MockContainerRuntime_GetContainerNetworkInfo_Call {
	return &MockContainerRuntime_GetContainerNetworkInfo_Call{Call: _e.mock.On("GetContainerNetworkInfo", ctx, containerID)}
}

func (_c *MockContainerRuntime_GetContainerNetworkInfo_Call) Run(run func(ctx context.Context, containerID string)) *MockContainerRuntime_GetContainerNetworkInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_GetContainerNetworkInfo_Call) Return(s string, n int, err error) *MockContainerRuntime_GetContainerNetworkInfo_Call {
	_c.Call.Return(s, n, err)
	return _c
}

func (_c *MockContainerRuntime_GetContainerNetworkInfo_Call) RunAndReturn(run func(ctx context.Context, containerID string) (string, int, error)) *MockContainerRuntime_GetContainerNetworkInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetContainerPort provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) GetContainerPort(ctx context.Context, containerID string, internalPort int) (int, error) {
	ret := _mock.Called(ctx, containerID, internalPort)

	if len(ret) == 0 {
		panic("no return value specified for GetContainerPort")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int) (int, error)); ok {
		return returnFunc(ctx, containerID, internalPort)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int) int); ok {
		r0 = returnFunc(ctx, containerID, internalPort)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = returnFunc(ctx, containerID, internalPort)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_GetContainerPort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContainerPort'
type MockContainerRuntime_GetContainerPort_Call struct {
	*mock.Call
}

// GetContainerPort is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
//   - internalPort int
func (_e *MockContainerRuntime_Expecter) GetContainerPort(ctx interface{}, containerID interface{}, internalPort interface{}) *MockContainerRuntime_GetContainerPort_Call {
	return &MockContainerRuntime_GetContainerPort_Call{Call: _e.mock.On("GetContainerPort", ctx, containerID, internalPort)}
}

func (_c *MockContainerRuntime_GetContainerPort_Call) Run(run func(ctx context.Context, containerID string, internalPort int)) *MockContainerRuntime_GetContainerPort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_GetContainerPort_Call) Return(n int, err error) *MockContainerRuntime_GetContainerPort_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockContainerRuntime_GetContainerPort_Call) RunAndReturn(run func(ctx context.Context, containerID string, internalPort int) (int, error)) *MockContainerRuntime_GetContainerPort_Call {
	_c.Call.Return(run)
	return _c
}

// GetImageExposedPorts provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) GetImageExposedPorts(ctx context.Context, imageRef string) ([]int, error) {
	ret := _mock.Called(ctx, imageRef)

	if len(ret) == 0 {
		panic("no return value specified for GetImageExposedPorts")
	}

	var r0 []int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]int, error)); ok {
		return returnFunc(ctx, imageRef)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []int); ok {
		r0 = returnFunc(ctx, imageRef)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, imageRef)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_GetImageExposedPorts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetImageExposedPorts'
type MockContainerRuntime_GetImageExposedPorts_Call struct {
	*mock.Call
}

// GetImageExposedPorts is a helper method to define mock.On call
//   - ctx context.Context
//   - imageRef string
func (_e *MockContainerRuntime_Expecter) GetImageExposedPorts(ctx interface{}, imageRef interface{}) *MockContainerRuntime_GetImageExposedPorts_Call {
	return &MockContainerRuntime_GetImageExposedPorts_Call{Call: _e.mock.On("GetImageExposedPorts", ctx, imageRef)}
}

func (_c *MockContainerRuntime_GetImageExposedPorts_Call) Run(run func(ctx context.Context, imageRef string)) *MockContainerRuntime_GetImageExposedPorts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_GetImageExposedPorts_Call) Return(ints []int, err error) *MockContainerRuntime_GetImageExposedPorts_Call {
	_c.Call.Return(ints, err)
	return _c
}

func (_c *MockContainerRuntime_GetImageExposedPorts_Call) RunAndReturn(run func(ctx context.Context, imageRef string) ([]int, error)) *MockContainerRuntime_GetImageExposedPorts_Call {
	_c.Call.Return(run)
	return _c
}

// GetImageLabels provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) GetImageLabels(ctx context.Context, imageRef string) (map[string]string, error) {
	ret := _mock.Called(ctx, imageRef)

	if len(ret) == 0 {
		panic("no return value specified for GetImageLabels")
	}

	var r0 map[string]string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (map[string]string, error)); ok {
		return returnFunc(ctx, imageRef)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) map[string]string); ok {
		r0 = returnFunc(ctx, imageRef)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, imageRef)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_GetImageLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetImageLabels'
type MockContainerRuntime_GetImageLabels_Call struct {
	*mock.Call
}

// GetImageLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - imageRef string
func (_e *MockContainerRuntime_Expecter) GetImageLabels(ctx interface{}, imageRef interface{}) *MockContainerRuntime_GetImageLabels_Call {
	return &MockContainerRuntime_GetImageLabels_Call{Call: _e.mock.On("GetImageLabels", ctx, imageRef)}
}

func (_c *MockContainerRuntime_GetImageLabels_Call) Run(run func(ctx context.Context, imageRef string)) *MockContainerRuntime_GetImageLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_GetImageLabels_Call) Return(stringToString map[string]string, err error) *MockContainerRuntime_GetImageLabels_Call {
	_c.Call.Return(stringToString, err)
	return _c
}

func (_c *MockContainerRuntime_GetImageLabels_Call) RunAndReturn(run func(ctx context.Context, imageRef string) (map[string]string, error)) *MockContainerRuntime_GetImageLabels_Call {
	_c.Call.Return(run)
	return _c
}

// InspectContainer provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) InspectContainer(ctx context.Context, containerID string) (*domain.Container, error) {
	ret := _mock.Called(ctx, containerID)

	if len(ret) == 0 {
		panic("no return value specified for InspectContainer")
	}

	var r0 *domain.Container
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*domain.Container, error)); ok {
		return returnFunc(ctx, containerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *domain.Container); ok {
		r0 = returnFunc(ctx, containerID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Container)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, containerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_InspectContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InspectContainer'
type MockContainerRuntime_InspectContainer_Call struct {
	*mock.Call
}

// InspectContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
func (_e *MockContainerRuntime_Expecter) InspectContainer(ctx interface{}, containerID interface{}) *MockContainerRuntime_InspectContainer_Call {
	return &MockContainerRuntime_InspectContainer_Call{Call: _e.mock.On("InspectContainer", ctx, containerID)}
}

func (_c *MockContainerRuntime_InspectContainer_Call) Run(run func(ctx context.Context, containerID string)) *MockContainerRuntime_InspectContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_InspectContainer_Call) Return(container *domain.Container, err error) *MockContainerRuntime_InspectContainer_Call {
	_c.Call.Return(container, err)
	return _c
}

func (_c *MockContainerRuntime_InspectContainer_Call) RunAndReturn(run func(ctx context.Context, containerID string) (*domain.Container, error)) *MockContainerRuntime_InspectContainer_Call {
	_c.Call.Return(run)
	return _c
}

// InspectImageEnv provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) InspectImageEnv(ctx context.Context, imageRef string) ([]string, error) {
	ret := _mock.Called(ctx, imageRef)

	if len(ret) == 0 {
		panic("no return value specified for InspectImageEnv")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]string, error)); ok {
		return returnFunc(ctx, imageRef)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = returnFunc(ctx, imageRef)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, imageRef)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_InspectImageEnv_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InspectImageEnv'
type MockContainerRuntime_InspectImageEnv_Call struct {
	*mock.Call
}

// InspectImageEnv is a helper method to define mock.On call
//   - ctx context.Context
//   - imageRef string
func (_e *MockContainerRuntime_Expecter) InspectImageEnv(ctx interface{}, imageRef interface{}) *MockContainerRuntime_InspectImageEnv_Call {
	return &MockContainerRuntime_InspectImageEnv_Call{Call: _e.mock.On("InspectImageEnv", ctx, imageRef)}
}

func (_c *MockContainerRuntime_InspectImageEnv_Call) Run(run func(ctx context.Context, imageRef string)) *MockContainerRuntime_InspectImageEnv_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_InspectImageEnv_Call) Return(strings []string, err error) *MockContainerRuntime_InspectImageEnv_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *MockContainerRuntime_InspectImageEnv_Call) RunAndReturn(run func(ctx context.Context, imageRef string) ([]string, error)) *MockContainerRuntime_InspectImageEnv_Call {
	_c.Call.Return(run)
	return _c
}

// InspectImageVolumes provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) InspectImageVolumes(ctx context.Context, imageRef string) ([]string, error) {
	ret := _mock.Called(ctx, imageRef)

	if len(ret) == 0 {
		panic("no return value specified for InspectImageVolumes")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) ([]string, error)); ok {
		return returnFunc(ctx, imageRef)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = returnFunc(ctx, imageRef)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, imageRef)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_InspectImageVolumes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InspectImageVolumes'
type MockContainerRuntime_InspectImageVolumes_Call struct {
	*mock.Call
}

// InspectImageVolumes is a helper method to define mock.On call
//   - ctx context.Context
//   - imageRef string
func (_e *MockContainerRuntime_Expecter) InspectImageVolumes(ctx interface{}, imageRef interface{}) *MockContainerRuntime_InspectImageVolumes_Call {
	return &MockContainerRuntime_InspectImageVolumes_Call{Call: _e.mock.On("InspectImageVolumes", ctx, imageRef)}
}

func (_c *MockContainerRuntime_InspectImageVolumes_Call) Run(run func(ctx context.Context, imageRef string)) *MockContainerRuntime_InspectImageVolumes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_InspectImageVolumes_Call) Return(strings []string, err error) *MockContainerRuntime_InspectImageVolumes_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *MockContainerRuntime_InspectImageVolumes_Call) RunAndReturn(run func(ctx context.Context, imageRef string) ([]string, error)) *MockContainerRuntime_InspectImageVolumes_Call {
	_c.Call.Return(run)
	return _c
}

// IsContainerRunning provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) IsContainerRunning(ctx context.Context, containerID string) (bool, error) {
	ret := _mock.Called(ctx, containerID)

	if len(ret) == 0 {
		panic("no return value specified for IsContainerRunning")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, containerID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, containerID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, containerID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_IsContainerRunning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsContainerRunning'
type MockContainerRuntime_IsContainerRunning_Call struct {
	*mock.Call
}

// IsContainerRunning is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
func (_e *MockContainerRuntime_Expecter) IsContainerRunning(ctx interface{}, containerID interface{}) *MockContainerRuntime_IsContainerRunning_Call {
	return &MockContainerRuntime_IsContainerRunning_Call{Call: _e.mock.On("IsContainerRunning", ctx, containerID)}
}

func (_c *MockContainerRuntime_IsContainerRunning_Call) Run(run func(ctx context.Context, containerID string)) *MockContainerRuntime_IsContainerRunning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_IsContainerRunning_Call) Return(b bool, err error) *MockContainerRuntime_IsContainerRunning_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockContainerRuntime_IsContainerRunning_Call) RunAndReturn(run func(ctx context.Context, containerID string) (bool, error)) *MockContainerRuntime_IsContainerRunning_Call {
	_c.Call.Return(run)
	return _c
}

// ListContainers provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) ListContainers(ctx context.Context, all bool) ([]*domain.Container, error) {
	ret := _mock.Called(ctx, all)

	if len(ret) == 0 {
		panic("no return value specified for ListContainers")
	}

	var r0 []*domain.Container
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bool) ([]*domain.Container, error)); ok {
		return returnFunc(ctx, all)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bool) []*domain.Container); ok {
		r0 = returnFunc(ctx, all)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.Container)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = returnFunc(ctx, all)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_ListContainers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListContainers'
type MockContainerRuntime_ListContainers_Call struct {
	*mock.Call
}

// ListContainers is a helper method to define mock.On call
//   - ctx context.Context
//   - all bool
func (_e *MockContainerRuntime_Expecter) ListContainers(ctx interface{}, all interface{}) *MockContainerRuntime_ListContainers_Call {
	return &MockContainerRuntime_ListContainers_Call{Call: _e.mock.On("ListContainers", ctx, all)}
}

func (_c *MockContainerRuntime_ListContainers_Call) Run(run func(ctx context.Context, all bool)) *MockContainerRuntime_ListContainers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 bool
		if args[1] != nil {
			arg1 = args[1].(bool)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_ListContainers_Call) Return(containers []*domain.Container, err error) *MockContainerRuntime_ListContainers_Call {
	_c.Call.Return(containers, err)
	return _c
}

func (_c *MockContainerRuntime_ListContainers_Call) RunAndReturn(run func(ctx context.Context, all bool) ([]*domain.Container, error)) *MockContainerRuntime_ListContainers_Call {
	_c.Call.Return(run)
	return _c
}

// ListImages provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) ListImages(ctx context.Context) ([]string, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListImages")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_ListImages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListImages'
type MockContainerRuntime_ListImages_Call struct {
	*mock.Call
}

// ListImages is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockContainerRuntime_Expecter) ListImages(ctx interface{}) *MockContainerRuntime_ListImages_Call {
	return &MockContainerRuntime_ListImages_Call{Call: _e.mock.On("ListImages", ctx)}
}

func (_c *MockContainerRuntime_ListImages_Call) Run(run func(ctx context.Context)) *MockContainerRuntime_ListImages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_ListImages_Call) Return(strings []string, err error) *MockContainerRuntime_ListImages_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *MockContainerRuntime_ListImages_Call) RunAndReturn(run func(ctx context.Context) ([]string, error)) *MockContainerRuntime_ListImages_Call {
	_c.Call.Return(run)
	return _c
}

// ListNetworks provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) ListNetworks(ctx context.Context) ([]*domain.NetworkInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListNetworks")
	}

	var r0 []*domain.NetworkInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*domain.NetworkInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*domain.NetworkInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.NetworkInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_ListNetworks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListNetworks'
type MockContainerRuntime_ListNetworks_Call struct {
	*mock.Call
}

// ListNetworks is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockContainerRuntime_Expecter) ListNetworks(ctx interface{}) *MockContainerRuntime_ListNetworks_Call {
	return &MockContainerRuntime_ListNetworks_Call{Call: _e.mock.On("ListNetworks", ctx)}
}

func (_c *MockContainerRuntime_ListNetworks_Call) Run(run func(ctx context.Context)) *MockContainerRuntime_ListNetworks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_ListNetworks_Call) Return(networkInfos []*domain.NetworkInfo, err error) *MockContainerRuntime_ListNetworks_Call {
	_c.Call.Return(networkInfos, err)
	return _c
}

func (_c *MockContainerRuntime_ListNetworks_Call) RunAndReturn(run func(ctx context.Context) ([]*domain.NetworkInfo, error)) *MockContainerRuntime_ListNetworks_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkExists provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) NetworkExists(ctx context.Context, name string) (bool, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for NetworkExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, name)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_NetworkExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkExists'
type MockContainerRuntime_NetworkExists_Call struct {
	*mock.Call
}

// NetworkExists is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockContainerRuntime_Expecter) NetworkExists(ctx interface{}, name interface{}) *MockContainerRuntime_NetworkExists_Call {
	return &MockContainerRuntime_NetworkExists_Call{Call: _e.mock.On("NetworkExists", ctx, name)}
}

func (_c *MockContainerRuntime_NetworkExists_Call) Run(run func(ctx context.Context, name string)) *MockContainerRuntime_NetworkExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_NetworkExists_Call) Return(b bool, err error) *MockContainerRuntime_NetworkExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockContainerRuntime_NetworkExists_Call) RunAndReturn(run func(ctx context.Context, name string) (bool, error)) *MockContainerRuntime_NetworkExists_Call {
	_c.Call.Return(run)
	return _c
}

// Ping provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) Ping(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type MockContainerRuntime_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockContainerRuntime_Expecter) Ping(ctx interface{}) *MockContainerRuntime_Ping_Call {
	return &MockContainerRuntime_Ping_Call{Call: _e.mock.On("Ping", ctx)}
}

func (_c *MockContainerRuntime_Ping_Call) Run(run func(ctx context.Context)) *MockContainerRuntime_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_Ping_Call) Return(err error) *MockContainerRuntime_Ping_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_Ping_Call) RunAndReturn(run func(ctx context.Context) error) *MockContainerRuntime_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// PullImage provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) PullImage(ctx context.Context, image string) error {
	ret := _mock.Called(ctx, image)

	if len(ret) == 0 {
		panic("no return value specified for PullImage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, image)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_PullImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PullImage'
type MockContainerRuntime_PullImage_Call struct {
	*mock.Call
}

// PullImage is a helper method to define mock.On call
//   - ctx context.Context
//   - image string
func (_e *MockContainerRuntime_Expecter) PullImage(ctx interface{}, image interface{}) *MockContainerRuntime_PullImage_Call {
	return &MockContainerRuntime_PullImage_Call{Call: _e.mock.On("PullImage", ctx, image)}
}

func (_c *MockContainerRuntime_PullImage_Call) Run(run func(ctx context.Context, image string)) *MockContainerRuntime_PullImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_PullImage_Call) Return(err error) *MockContainerRuntime_PullImage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_PullImage_Call) RunAndReturn(run func(ctx context.Context, image string) error) *MockContainerRuntime_PullImage_Call {
	_c.Call.Return(run)
	return _c
}

// PullImageWithAuth provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) PullImageWithAuth(ctx context.Context, image string, username string, password string) error {
	ret := _mock.Called(ctx, image, username, password)

	if len(ret) == 0 {
		panic("no return value specified for PullImageWithAuth")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = returnFunc(ctx, image, username, password)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_PullImageWithAuth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PullImageWithAuth'
type MockContainerRuntime_PullImageWithAuth_Call struct {
	*mock.Call
}

// PullImageWithAuth is a helper method to define mock.On call
//   - ctx context.Context
//   - image string
//   - username string
//   - password string
func (_e *MockContainerRuntime_Expecter) PullImageWithAuth(ctx interface{}, image interface{}, username interface{}, password interface{}) *MockContainerRuntime_PullImageWithAuth_Call {
	return &MockContainerRuntime_PullImageWithAuth_Call{Call: _e.mock.On("PullImageWithAuth", ctx, image, username, password)}
}

func (_c *MockContainerRuntime_PullImageWithAuth_Call) Run(run func(ctx context.Context, image string, username string, password string)) *MockContainerRuntime_PullImageWithAuth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_PullImageWithAuth_Call) Return(err error) *MockContainerRuntime_PullImageWithAuth_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_PullImageWithAuth_Call) RunAndReturn(run func(ctx context.Context, image string, username string, password string) error) *MockContainerRuntime_PullImageWithAuth_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveContainer provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) RemoveContainer(ctx context.Context, containerID string, force bool) error {
	ret := _mock.Called(ctx, containerID, force)

	if len(ret) == 0 {
		panic("no return value specified for RemoveContainer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = returnFunc(ctx, containerID, force)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_RemoveContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveContainer'
type MockContainerRuntime_RemoveContainer_Call struct {
	*mock.Call
}

// RemoveContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
//   - force bool
func (_e *MockContainerRuntime_Expecter) RemoveContainer(ctx interface{}, containerID interface{}, force interface{}) *MockContainerRuntime_RemoveContainer_Call {
	return &MockContainerRuntime_RemoveContainer_Call{Call: _e.mock.On("RemoveContainer", ctx, containerID, force)}
}

func (_c *MockContainerRuntime_RemoveContainer_Call) Run(run func(ctx context.Context, containerID string, force bool)) *MockContainerRuntime_RemoveContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_RemoveContainer_Call) Return(err error) *MockContainerRuntime_RemoveContainer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_RemoveContainer_Call) RunAndReturn(run func(ctx context.Context, containerID string, force bool) error) *MockContainerRuntime_RemoveContainer_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveImage provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) RemoveImage(ctx context.Context, image string, force bool) error {
	ret := _mock.Called(ctx, image, force)

	if len(ret) == 0 {
		panic("no return value specified for RemoveImage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = returnFunc(ctx, image, force)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_RemoveImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveImage'
type MockContainerRuntime_RemoveImage_Call struct {
	*mock.Call
}

// RemoveImage is a helper method to define mock.On call
//   - ctx context.Context
//   - image string
//   - force bool
func (_e *MockContainerRuntime_Expecter) RemoveImage(ctx interface{}, image interface{}, force interface{}) *MockContainerRuntime_RemoveImage_Call {
	return &MockContainerRuntime_RemoveImage_Call{Call: _e.mock.On("RemoveImage", ctx, image, force)}
}

func (_c *MockContainerRuntime_RemoveImage_Call) Run(run func(ctx context.Context, image string, force bool)) *MockContainerRuntime_RemoveImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_RemoveImage_Call) Return(err error) *MockContainerRuntime_RemoveImage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_RemoveImage_Call) RunAndReturn(run func(ctx context.Context, image string, force bool) error) *MockContainerRuntime_RemoveImage_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNetwork provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) RemoveNetwork(ctx context.Context, name string) error {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNetwork")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, name)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_RemoveNetwork_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNetwork'
type MockContainerRuntime_RemoveNetwork_Call struct {
	*mock.Call
}

// RemoveNetwork is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockContainerRuntime_Expecter) RemoveNetwork(ctx interface{}, name interface{}) *MockContainerRuntime_RemoveNetwork_Call {
	return &MockContainerRuntime_RemoveNetwork_Call{Call: _e.mock.On("RemoveNetwork", ctx, name)}
}

func (_c *MockContainerRuntime_RemoveNetwork_Call) Run(run func(ctx context.Context, name string)) *MockContainerRuntime_RemoveNetwork_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_RemoveNetwork_Call) Return(err error) *MockContainerRuntime_RemoveNetwork_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_RemoveNetwork_Call) RunAndReturn(run func(ctx context.Context, name string) error) *MockContainerRuntime_RemoveNetwork_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveVolume provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) RemoveVolume(ctx context.Context, volumeName string, force bool) error {
	ret := _mock.Called(ctx, volumeName, force)

	if len(ret) == 0 {
		panic("no return value specified for RemoveVolume")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = returnFunc(ctx, volumeName, force)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_RemoveVolume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveVolume'
type MockContainerRuntime_RemoveVolume_Call struct {
	*mock.Call
}

// RemoveVolume is a helper method to define mock.On call
//   - ctx context.Context
//   - volumeName string
//   - force bool
func (_e *MockContainerRuntime_Expecter) RemoveVolume(ctx interface{}, volumeName interface{}, force interface{}) *MockContainerRuntime_RemoveVolume_Call {
	return &MockContainerRuntime_RemoveVolume_Call{Call: _e.mock.On("RemoveVolume", ctx, volumeName, force)}
}

func (_c *MockContainerRuntime_RemoveVolume_Call) Run(run func(ctx context.Context, volumeName string, force bool)) *MockContainerRuntime_RemoveVolume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_RemoveVolume_Call) Return(err error) *MockContainerRuntime_RemoveVolume_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_RemoveVolume_Call) RunAndReturn(run func(ctx context.Context, volumeName string, force bool) error) *MockContainerRuntime_RemoveVolume_Call {
	_c.Call.Return(run)
	return _c
}

// RenameContainer provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) RenameContainer(ctx context.Context, containerID string, newName string) error {
	ret := _mock.Called(ctx, containerID, newName)

	if len(ret) == 0 {
		panic("no return value specified for RenameContainer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, containerID, newName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_RenameContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenameContainer'
type MockContainerRuntime_RenameContainer_Call struct {
	*mock.Call
}

// RenameContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
//   - newName string
func (_e *MockContainerRuntime_Expecter) RenameContainer(ctx interface{}, containerID interface{}, newName interface{}) *MockContainerRuntime_RenameContainer_Call {
	return &MockContainerRuntime_RenameContainer_Call{Call: _e.mock.On("RenameContainer", ctx, containerID, newName)}
}

func (_c *MockContainerRuntime_RenameContainer_Call) Run(run func(ctx context.Context, containerID string, newName string)) *MockContainerRuntime_RenameContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_RenameContainer_Call) Return(err error) *MockContainerRuntime_RenameContainer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_RenameContainer_Call) RunAndReturn(run func(ctx context.Context, containerID string, newName string) error) *MockContainerRuntime_RenameContainer_Call {
	_c.Call.Return(run)
	return _c
}

// RestartContainer provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) RestartContainer(ctx context.Context, containerID string) error {
	ret := _mock.Called(ctx, containerID)

	if len(ret) == 0 {
		panic("no return value specified for RestartContainer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, containerID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_RestartContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestartContainer'
type MockContainerRuntime_RestartContainer_Call struct {
	*mock.Call
}

// RestartContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
func (_e *MockContainerRuntime_Expecter) RestartContainer(ctx interface{}, containerID interface{}) *MockContainerRuntime_RestartContainer_Call {
	return &MockContainerRuntime_RestartContainer_Call{Call: _e.mock.On("RestartContainer", ctx, containerID)}
}

func (_c *MockContainerRuntime_RestartContainer_Call) Run(run func(ctx context.Context, containerID string)) *MockContainerRuntime_RestartContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_RestartContainer_Call) Return(err error) *MockContainerRuntime_RestartContainer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_RestartContainer_Call) RunAndReturn(run func(ctx context.Context, containerID string) error) *MockContainerRuntime_RestartContainer_Call {
	_c.Call.Return(run)
	return _c
}

// StartContainer provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) StartContainer(ctx context.Context, containerID string) error {
	ret := _mock.Called(ctx, containerID)

	if len(ret) == 0 {
		panic("no return value specified for StartContainer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, containerID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_StartContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartContainer'
type MockContainerRuntime_StartContainer_Call struct {
	*mock.Call
}

// StartContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
func (_e *MockContainerRuntime_Expecter) StartContainer(ctx interface{}, containerID interface{}) *MockContainerRuntime_StartContainer_Call {
	return &MockContainerRuntime_StartContainer_Call{Call: _e.mock.On("StartContainer", ctx, containerID)}
}

func (_c *MockContainerRuntime_StartContainer_Call) Run(run func(ctx context.Context, containerID string)) *MockContainerRuntime_StartContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_StartContainer_Call) Return(err error) *MockContainerRuntime_StartContainer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_StartContainer_Call) RunAndReturn(run func(ctx context.Context, containerID string) error) *MockContainerRuntime_StartContainer_Call {
	_c.Call.Return(run)
	return _c
}

// StopContainer provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) StopContainer(ctx context.Context, containerID string) error {
	ret := _mock.Called(ctx, containerID)

	if len(ret) == 0 {
		panic("no return value specified for StopContainer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, containerID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_StopContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopContainer'
type MockContainerRuntime_StopContainer_Call struct {
	*mock.Call
}

// StopContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - containerID string
func (_e *MockContainerRuntime_Expecter) StopContainer(ctx interface{}, containerID interface{}) *MockContainerRuntime_StopContainer_Call {
	return &MockContainerRuntime_StopContainer_Call{Call: _e.mock.On("StopContainer", ctx, containerID)}
}

func (_c *MockContainerRuntime_StopContainer_Call) Run(run func(ctx context.Context, containerID string)) *MockContainerRuntime_StopContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_StopContainer_Call) Return(err error) *MockContainerRuntime_StopContainer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_StopContainer_Call) RunAndReturn(run func(ctx context.Context, containerID string) error) *MockContainerRuntime_StopContainer_Call {
	_c.Call.Return(run)
	return _c
}

// TagImage provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) TagImage(ctx context.Context, sourceRef string, targetRef string) error {
	ret := _mock.Called(ctx, sourceRef, targetRef)

	if len(ret) == 0 {
		panic("no return value specified for TagImage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, sourceRef, targetRef)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_TagImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TagImage'
type MockContainerRuntime_TagImage_Call struct {
	*mock.Call
}

// TagImage is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceRef string
//   - targetRef string
func (_e *MockContainerRuntime_Expecter) TagImage(ctx interface{}, sourceRef interface{}, targetRef interface{}) *MockContainerRuntime_TagImage_Call {
	return &MockContainerRuntime_TagImage_Call{Call: _e.mock.On("TagImage", ctx, sourceRef, targetRef)}
}

func (_c *MockContainerRuntime_TagImage_Call) Run(run func(ctx context.Context, sourceRef string, targetRef string)) *MockContainerRuntime_TagImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_TagImage_Call) Return(err error) *MockContainerRuntime_TagImage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_TagImage_Call) RunAndReturn(run func(ctx context.Context, sourceRef string, targetRef string) error) *MockContainerRuntime_TagImage_Call {
	_c.Call.Return(run)
	return _c
}

// UntagImage provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) UntagImage(ctx context.Context, imageRef string) error {
	ret := _mock.Called(ctx, imageRef)

	if len(ret) == 0 {
		panic("no return value specified for UntagImage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, imageRef)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainerRuntime_UntagImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UntagImage'
type MockContainerRuntime_UntagImage_Call struct {
	*mock.Call
}

// UntagImage is a helper method to define mock.On call
//   - ctx context.Context
//   - imageRef string
func (_e *MockContainerRuntime_Expecter) UntagImage(ctx interface{}, imageRef interface{}) *MockContainerRuntime_UntagImage_Call {
	return &MockContainerRuntime_UntagImage_Call{Call: _e.mock.On("UntagImage", ctx, imageRef)}
}

func (_c *MockContainerRuntime_UntagImage_Call) Run(run func(ctx context.Context, imageRef string)) *MockContainerRuntime_UntagImage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_UntagImage_Call) Return(err error) *MockContainerRuntime_UntagImage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainerRuntime_UntagImage_Call) RunAndReturn(run func(ctx context.Context, imageRef string) error) *MockContainerRuntime_UntagImage_Call {
	_c.Call.Return(run)
	return _c
}

// Version provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) Version(ctx context.Context) (string, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Version")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_Version_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Version'
type MockContainerRuntime_Version_Call struct {
	*mock.Call
}

// Version is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockContainerRuntime_Expecter) Version(ctx interface{}) *MockContainerRuntime_Version_Call {
	return &MockContainerRuntime_Version_Call{Call: _e.mock.On("Version", ctx)}
}

func (_c *MockContainerRuntime_Version_Call) Run(run func(ctx context.Context)) *MockContainerRuntime_Version_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_Version_Call) Return(s string, err error) *MockContainerRuntime_Version_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockContainerRuntime_Version_Call) RunAndReturn(run func(ctx context.Context) (string, error)) *MockContainerRuntime_Version_Call {
	_c.Call.Return(run)
	return _c
}

// VolumeExists provides a mock function for the type MockContainerRuntime
func (_mock *MockContainerRuntime) VolumeExists(ctx context.Context, volumeName string) (bool, error) {
	ret := _mock.Called(ctx, volumeName)

	if len(ret) == 0 {
		panic("no return value specified for VolumeExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, volumeName)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, volumeName)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, volumeName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainerRuntime_VolumeExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VolumeExists'
type MockContainerRuntime_VolumeExists_Call struct {
	*mock.Call
}

// VolumeExists is a helper method to define mock.On call
//   - ctx context.Context
//   - volumeName string
func (_e *MockContainerRuntime_Expecter) VolumeExists(ctx interface{}, volumeName interface{}) *MockContainerRuntime_VolumeExists_Call {
	return &MockContainerRuntime_VolumeExists_Call{Call: _e.mock.On("VolumeExists", ctx, volumeName)}
}

func (_c *MockContainerRuntime_VolumeExists_Call) Run(run func(ctx context.Context, volumeName string)) *MockContainerRuntime_VolumeExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainerRuntime_VolumeExists_Call) Return(b bool, err error) *MockContainerRuntime_VolumeExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockContainerRuntime_VolumeExists_Call) RunAndReturn(run func(ctx context.Context, volumeName string) (bool, error)) *MockContainerRuntime_VolumeExists_Call {
	_c.Call.Return(run)
	return _c
}
